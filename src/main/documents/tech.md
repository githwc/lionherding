一、接口思想：
   1.1
     1)接口就是提供一种统一的'协议',而接口中的属性也属于'协议'中的成员，他们是公共的,静态的,最终的常量，相当于全局常量
     2)接口中的属性必然是常量,只能读不能改，这样才能为实现接口的对象提供一个统一的属性。通俗的讲,认为是要变化的东西,
       就放在自己的实现中,不能放在接口中,接口只是对一类事物的属性和行为更高层次的抽象。
       对修改关闭，对扩展（不同的实现implements）开放，接口是对开闭原则的一种体现。
     3)Jdk1.8中,接口中的变量默认是public static final
                接口中的方法默认是public abstract,除非是static方法或者默认方法
       public:接口可以被不同包的不同类实现，是公有的
       static:一个类实现多个接口时，即使存在同名变量也不会混淆。可以通过接口1.a,接口2.a的方式调用；
       final：该变量不可被修改。如果一个接口被多个类实现，在类1中改变了该变量的值，那么其他类中该变量的值也会变化，要防止该情况的发生
    1.2修饰符
        类修饰符：
	        public:将一个类声明为公共类,可以被任何对象访问
	        abstract:将一个类声明为抽象类,没有实现的方法,需要子类提供方法实现
	        final:将一个类声明为最终(即非继承类),表示他不能被其他类继承
	        friendly:默认的修饰符,只有在相同包中的对象才能使用这样的类
		成员变量修饰符：
			public:指定变量为公共的,他可以被任何对象的方法访问。
			protected:指定该变量可以别被自己的类和子类访问。在子类中可以覆盖此变量。
			friendly:同一个包中的类可以访问，其他包中的类不能访问。
			private:指定变量只允许自己的类的方法访问,其他任何类（包括子类）中的方法均不能访问。
			final:最终修饰符，指定此变量的值不能变。
			static:指定变量被所有对象共享，即所有实例都可以使用该变量。变量属于这个类。
			transient:（过度修饰符）指定该变量是系统保留，暂无特别作用的临时性变量。
			volatile（易失修饰符）指定该变量可以同时被几个线程控制和修改。
		方法修饰符：
			public：（公共控制符）
			private：指定此方法只能有自己类等方法访问，其他的类不能访问（包括子类）
			protected：指定该方法可以被它的类和子类进行访问。
			final:指定该方法不能被重载。
			static:指定不需要实例化就可以激活的一个方法。
			synchronize:同步修饰符,在多个线程中,该修饰符用于在运行前,对他所属的方法加锁,以防止其他线程的访问，运行结束后解锁。
			native:本地修饰符。指定此方法的方法体是用其他语言在程序外部编写的。
二、序列化Serializable
	概念：
		1、序列化：把java对象转换为字节序列的过程。(将对象的内容进行流化，可以对流化后的对象进行读写操作，也可将流化后的对象传输与网络之间)；
		2、反序列化：把字节序列恢复为java对象的过程。
		3、序列化是为了解决在对对象流进行读写操作时所引发的问题；  	
	用途：
		1、把对象的字节序列永久的保存到硬盘上，通常存放在一个文件中。
		2、在网络上传送对象的字节序列；
	serialVersionUID：
	private static final long serialVersionUID = 1L;
	首先解释Serializable序列化工作机制：序列化的时候系统会把当前类的serialVersionUID 写入序列化的文件中（也可能是其他中介），
	当反序列化的时候系统会去检测文件中的serialVersionUID ，看它是否和当前类的serialVersionUID 一致，如果一致就说明序列化的
	类的版本和当前类的版本是相同的，这个时候可以成功反序列化，否则就说明当前类和序列化的类相比发生了某些变换，比如成员变量的数量，
	类型可能发生了改变，这个时候就会抛异常，反序列化失败。那么serialVersionUID 是如何生成，生成规则是怎么样的呢？默认情况下，
	也就是不声明serialVersionUID 属性情况下，系统会按当前类的成员变量计算hash值并赋值给serialVersionUID 。所以，声明serialVersionUID，
	可以很大程度上避免反序列化过程的失败。比如当版本升级后，我们可能删除了某个成员变量，也可能增加了一些新的成员变量，这个时候我们的反序列化依然能够成功，
	程序依然能够最大程度地恢复数据，相反，如果不指定serialVersionUID ，程序就会挂掉。
	当然我们还要考虑另外一种情况，如果类结构发生了非常规性改变，比如修改了类名，类型等，这个时候尽管serialVersionUID 验证通过了，但是反序列化过程
	还是会失败，因为类结构有了毁灭性的改变。
	所以涉及到数据传输或者存储的类，严格意义上来说都要加上序列化ID，这也是一种良好的编程习惯。
三、日志
	1.日志级别
	概念：是一种机制，如果一条日志信息的级别大于等于配置文件的级别，就记录。
	介绍：
		trace:追踪,就是程序推进一下，可以写个trace输出
		debug:调试,一般作为最低级别,trace基本不用
		info:输出重要的信息,使用较多
		warn:警告,有些信息不是错误信息,但是也要给程序员一些提示
		error：错误信息
		fatal:致命错误
    2.log和System.out.print
        System.out.print的优点：直观、方便。
        Log的优点：异步、解耦、灵活、策略多。
        System.out.print和java运行程序运行在同一线程，也就是说，业务程序会等待System.out的动作，导致资源被占用，
        log4j、logback等日志工具进行调试信息的打印，这类工具是异步线程的，不会使程序处于等待状态。        
        System.out.print是在控制台输出，只能输出到控制台，而且日志文件需要保留，以供日后分析，是需要一套管理规范的，
        即便使用tomcat服务器，System.out会输出到catalina.out文件，catalina.out文件也不会一直存在，需要定期清空，
        如果不清空，大文件的读写也是挺影响性能的。说到这里，System.out.print写入的文件只有一个，对于一个文件的读写，
        这个io肯定会排队写，且System.out.print在当前线程，肯定对性能会有稍微的影响。程序中充斥着大量的System.out.print打印代码是相当不规范的。
四、异常
    通过@RestControllerAdvice 和 @ExceptionHandler 自定义异常
    使用方式:throw new ParameterException("错误内容")
五、shiro
    